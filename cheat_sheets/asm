#Cheat sheet für Assembly
By Axel

Nützliche Register:
(sobald uns der Nutzen erklärt wird, füge ich es ein) (befinden sich in der CPU)(

EAX	Acummulator ;Kann von Funktionen verändert werden
ECX	Count       ;Kann von Funktionen verändert werden
EDX	Doubble- used if an output is greater than the lenght of the possible output; Kann von Funktionen verändert werden
EBX	Base
ESI	Source Index
EDI	Destination Index

Register, aber besser nicht anfassen (Vom Stack, welcher sich in der Ram befindet)
ESP	Stack Pointer- Points to the current top of the stack
EBP	Base Pointer- Hält den Wert vom Esp aufrufenden Programm fest



Nützliche Operationen (falls ein Output existiert, wird er auf das erste Register gesetzt)

mov	Dest	Src	Kopiert Inhalt vom zweiten Register zum ersten
xchg	Reg1	Reg2	Vertauscht die beiden Werte
push	Source		Pusht den Inhalt des Registers in den Stack
pop	Sorce		Holt den letzten Inhalt aus den Stack raus
add	Dest	Src	Addirte Src auf Dest
sub	Dest	Src	Subtrahiert Scr von Dest (Dest=Src-Dest)
imul	Dest	Src	Scr	Multiplies signed number (up to 3). If no Scr is given, it is multiplyed by eax and saved on edx. Overflow is savend in edx
div	Dest	Src	Divides, saves extra in EDX (I think)
inc	Dest		Increases by 1
dec	Dest		Decreases by 1
sal	Dest		moves the number x bits to the left (111=>110 mit overflow) (signage isn't kept)
sar	Dest		moves number to the right; saves the signature through vodoo magic
shr	Dest		like sar, but doesn´t keep signage
AND	Dest	Src	Bitwise and Operation
OR	Dest	Src	Bitwise or Operation
TEST	Reg1	Reg2	Bitwise and Operation, but only changes the flags
cmp	Reg1	Reg2	Like  sub, but only updates flags
jmp	Location	Jumps to that location
LOOP	Location	Decrements ECX by one and jumps if ECX !==0
call	Location	jumps to that location and does it while saving its source in the stack for
cdq			Verbindet EAX und EDX sodass in EAX das Ganzteilige Teil einer Division erschient und in EDX der Rest
ret			(return) Returns back to the latest call
extern	Function_name	the #import of asm


Flags (and jumps related to them. They update after each operation
jz	ZF	Zero flag	Triggers if the last operation resulted in 0
jnz	Contrary
js	SF	Sign flag	Triggers if the last operation resulted in a negative number
jns	Contrary
jo	OF	Overflow flag	Triggers if overflow (like carry, but the number still is isn`t carrying into the next bit
jno	Contrary
jc	CF	Carry flag	Triggers if a carry happened on the last operation (unsigned operation)
jnc	Contrary
jp	PF	Parry flag	Triggers if a an even parity hapened (even number of 1s in the number)
jnp	Contrary


variable/destination_name:	a location where code can be written or a variable can be stored
[variable_name]		Way to acces a variable
variable_name: format variable_value

Variable formats: 
dd (double digit, just a normal 32bit)
arrays of strings are just v1: dd 10,11,12, accesed by using [vi+4*x]
db (string, written `string`0 (the 0 tells it to stop reading))

